Scala-AM: A Framework for Static Analysis of Dynamic Languages
* Goal
The goal of this artefact is to experiment with abstract machines and language
semantics. Currently, the artefact's implementation is focused towards experiments with modular analyses.

* Usage
The Scala-AM framework can be used in several ways.

** Running the test suite
The test suite of Scala-AM can be run using =sbt test=.
#+BEGIN_SRC shell
$ sbt
> test
#+END_SRC

** Using the JavaScript visual front-end
The framework includes a JavaScript front-end that can be used to visualise a MODF analysis in the browser.
To run this visualisation, open the file =scalaam.html= with your browser. The visualisation provides information with
regard to the work list (coloured in light blue) and currently analysed component (coloured in dark blue).
Stepping through the visualisation can be done using the space bar.

If you need to compile the code first, run the command =fastOptJS= within your sbt repl.

** Running a program in command line
The Scala-AM framework is built in a modular style. To run a modular analysis, you need to compose the
implementation of a specific machine and an abstract domain.

To analyze a specific program, an instance of the MODF analysis class must be created. The constructor of
this class takes a parsed version of the program to be analysed, which can be obtained as follows:
#+BEGIN_SRC scala
scala> val program = scalaam.cli.Main.loadFile(path-to-file)
#+END_SRC
Additional preprocessing steps can be performed as well if needed.

Now, the MODF instance can be created. For example, to analyze =exp= using a big-step MODF analysis
with full argument sensitivity and a type domain:
#+BEGIN_SRC scala
scala> val machine = new ModAnalysis(program) with BigStepSchemeModFSemantics
                                              with FullArgumentSensitivity
                                              with ConstantPropagationDomain
scala> machine.analyze()
#+END_SRC
This function can take an optional parameter to specify a timeout, which is obtained from a Java Duration
like =Timeout.start(duration)=. The analysis will stop approximately when the timeout has been reached. Note that
the timer starts from the moment where the =duration= method is called.

* References and Relevant publications
The idea behind Scala-AM comes from the [[http://matt.might.net/papers/vanhorn2010abstract.pdf][Abstracting Abstract Machines]]
literature and has integrated the work of [[https://doi.org/10.1007/978-3-030-11245-5_12][Effect-Driven Flow Analysis]].

The Scala-AM framework is described in the following publication:
  - Scala-AM: A Modular Static Analysis Framework. SCAM 2016. [[http://soft.vub.ac.be/Publications/2016/vub-soft-tr-16-07.pdf][pdf]], [[https://zenodo.org/badge/latestdoi/23603/acieroid/scala-am][doi]].
  - Building a Modular Static Analysis Framework in Scala. Scala@SPLASH 2016. [[http://soft.vub.ac.be/Publications/2016/vub-soft-tr-16-13.pdf][pdf]], [[http://doi.acm.org/10.1145/2998392.3001579][doi]].

Scala-AM has been used for evaluating static analysis approaches in the
following publications:
  - Garbage-Free Abstract Interpretation through Abstract Reference
    Counting. ECOOP 2019. [[http://drops.dagstuhl.de/opus/volltexte/2019/10784/][pdf]].
  - A general method for rendering static analyses for diverse concurrency
    models modular. Journal of Systems and Software, Volume 149. 2019. [[https://soft.vub.ac.be/~qstieven/fwo-proposal-jss.pdf][pdf]], [[https://doi.org/10.1016/j.jss.2018.10.001][doi]].
  - Mailbox Abstractions for Static Analysis of Actor Programs. ECOOP 2017. [[http://soft.vub.ac.be/~qstieven/ecoop2017/ecoop2017actors-final.pdf][pdf]],
    [[https://doi.org/10.4230/LIPIcs.ECOOP.2017.25][doi]].
  - Employing Run-time Static Analysis to Improve Concolic
    Execution. BENEVOL 2017. [[http://ceur-ws.org/Vol-2047/BENEVOL_2017_paper_7.pdf][pdf]].
  - Incrementalizing Abstract Interpretation. BENEVOL 2017. [[http://ceur-ws.org/Vol-2047/BENEVOL_2017_paper_9.pdf][pdf]].
  - Static taint analysis of event-driven scheme programs. ELS 2017. [[http://soft.vub.ac.be/Publications/2017/vub-soft-tr-17-02.pdf][pdf]].
  - Improving trace-based JIT optimisation using whole-program
    information. VMIL@SPLASH 2016. [[http://soft.vub.ac.be/Publications/2016/vub-soft-tr-16-09.pdf][pdf]], [[http://doi.acm.org/10.1145/2998415.2998418][doi]].
  - STRAF: A Scala Framework for Experiments in Trace-Based JIT
    Compilation. GTTSE 2015. [[http://soft.vub.ac.be/Publications/2017/vub-soft-tr-17-09.pdf][pdf]], [[https://doi.org/10.1007/978-3-319-60074-1\_10][doi]].
