package maf.modular.scv

import maf.language.ContractScheme.ContractValues.*
import maf.language.symbolic.*
import maf.language.symbolic.Symbolic.*
import maf.core.{Address, Monad}
import maf.core.Monad.MonadSyntaxOps
import maf.core.Monad.MonadIterableOps

/** A dataclass that holds all the information needed for a function summary */
case class FunctionSummary[V](
    /**
     * A collection of blames reported by the function, together with the formula that must be true in order fo the blame to be emitted. The second
     * element of the pair indicates whether the formula is satisfiable or not, from the perspective of a caller.
     */
    blames: Map[Blame, (Formula, IsSat[V])],
    /** A collection of paths generated by the execution of the function, as described by its path condition. */
    paths: Set[(V, PathCondition)],
    /** A collection of addresses used for their symbolic representation in the formulas in the path */
    addresses: Map[Symbolic, Set[Address]],
    addressRev: Map[Address, Symbolic],
    /** A collection that keeps track of the symbolic variables owned by this component */
    vars: Set[Symbolic])

/** An analysis that generates function summaries for each function. */
trait FunctionSummaryAnalysis extends BaseScvBigStepSemantics with ScvIgnoreFreshBlame:
    var functionSummaries: Map[Component, Option[FunctionSummary[Value]]] = Map().withDefaultValue(None)

    override def intraAnalysis(component: Component): FunctionSummaryIntra

    trait FunctionSummaryIntra extends BaseIntraScvSemantics with IntraScvIgnoreFreshBlames:
        private var blames: List[(Blame, PathCondition)] = List()
        private var addresses: Map[Symbolic, Set[Address]] = Map().withDefaultValue(Set())
        private var addressesRev: Map[Address, Symbolic] = Map()
        private var vars: Set[Symbolic] = Set()
        private lazy val myFnArgs = fnArgs

        private def buildSummary(results: Set[(PostValue, PathCondition)]): FunctionSummary[Value] =
            val summaryBlames = blames.map { case (blame, pc) => (blame -> (pc.formula, Sat[Value](Map()))) }.toMap
            val summaryResults = results.map { case (pv, pc) => (pv.value, pc) }
            FunctionSummary(blames = summaryBlames, paths = summaryResults, addresses = addresses, vars = vars, addressRev = addressesRev)

        /** Stores the summary in a global store such that it is accessible from the otuer intra analyses */
        private def storeSummary(summary: FunctionSummary[Value]): Unit =
            println(s"$component -- storing summary:\nblames: ${summary.blames}\npaths: ${summary.paths}\naddresses: ${summary.addresses}\n\n")
            functionSummaries = functionSummaries + (component -> Some(summary))

        /** Registers the blame such that it can be collected in the function summary */
        private def collectBlame(pc: PathCondition, blame: Blame): Unit =
            if !ignoreIdns.contains(blame.blamedPosition) then blames = (blame -> pc) :: blames

        private def trackAddresses(addr: Addr, sym: Symbolic, ignoreSelf: Boolean = true): Unit =
            // A symbolic write to our own arguments is always done at the beginning of the function.
            // Since that symbolic write is unconstrained (the variable is fresh and does not have any constrained associated with it), we can simply ignore any other write to it. The only difference is that we lose precision by ignoring the other write.
            if !(myFnArgs.contains(addr) && ignoreSelf) then
                addresses = addresses + (sym -> (addresses(sym) + addr))
                addressesRev = addressesRev + (addr -> sym)

        /**
         * Clean replaces the expressions from the mapping in the given formula, and (if necessary) alpha renames any collisions as given by the list
         * of variables in `vars`.
         *
         * Any constraints in the path condition that are not about any known variables, will be removed.
         *
         * @param pc
         *   the formula that needs to be cleaned
         * @param mapping
         *   a mapping (from, to) of expressions `from` that must be replaced by expressions `to` in `pc`
         * @param vars
         *   a list of variables used in the current component. Any clashing variables in `pc` (not included the ones in `to`) will be alpha renamed.
         */
        protected def clean(pc: Formula, mapping: List[(Symbolic, Symbolic)], vars: Set[Symbolic]): Formula = ???

        /**
         * Compose the current function summary with the received function summary
         *
         * @param targetCmp
         *   the component the summary originated from
         * @param summary
         *   the function summary itself
         */
        protected def composeWith(targetCmp: Component, summary: FunctionSummary[Value]): EvalM[Unit] =
            import FormulaAux.*
            // find a mapping between the arguments of the called function and our symbolic variables
            val args = fnArgs(targetCmp)
            val mapping = args.flatMap((adr) => addressesRev.get(adr).flatMap(s => summary.addressRev.get(adr).map(s2 => s2 -> s))).toList
            summary.blames
                .mapM { case (blame, (pc, _)) =>
                    val cleaned = clean(pc, mapping, vars)
                    for
                        originalPc <- getPc
                        isFeasible <- scvMonadInstance.unit(sat.feasible(conj(originalPc.formula, cleaned)))
                        // if the blame is still feasiable, we must propagate it.
                        result <-
                            if isFeasible then effectful { collectBlame(PathCondition(conj(originalPc.formula, cleaned)), blame) }
                            else scvMonadInstance.unit(())
                    yield result
                }
                .map(_ => ())

        /** Stores a function summary in a global map after analyzing the current component */
        override protected def runIntraSemantics(initialState: State): Set[(PostValue, PathCondition)] =
            val results = super.runIntraSemantics(initialState)
            val summary = buildSummary(results)
            storeSummary(summary)
            results

        /** Inject fresh symbolic variables for each variable in the list of arguments (if any) */
        override def injectCtx: EvalM[Unit] =
            for
                // ASSUMPTION: the counter of fresh variables is 0
                st <- scvMonadInstance.get
                _ = { assert(st.freshVar == 0) }
                // Map all function arguments to fresh variables
                argsCache <- fnArgs.toList.mapM(addr => fresh.map(e => (addr -> e)))
                _ <- Monad.sequence(argsCache.map { case (addr, e) =>
                    effectful { trackAddresses(addr, e, ignoreSelf = false) }
                })
                cache <- getStoreCache
                _ <- putStoreCache(cache ++ argsCache)
            yield ()

        override def writeSymbolic(addr: Addr)(e: Symbolic): EvalM[Symbolic] =
            // Keep track for all symbolic expressions on which addresses they are written.
            effectful { trackAddresses(addr, e) } >>>
                super.writeSymbolic(addr)(e)
        override def writeAddr(addr: Addr, vlu: Value): Boolean =
            // writeAddr can also write a symbolic value to a particular address (if getRight != Set()).
            lattice.getRight(vlu).foreach(e => trackAddresses(addr, e))
            super.writeAddr(addr, vlu)

        override def fresh: EvalM[Symbolic] =
            super.fresh.flatMap(e => effectful { vars = vars + e } >>> scvMonadInstance.unit(e))

        /**
         * This specialisation of doBlame does not write the blame directly to the global store, but instead delays that effect by writing it to the
         * function summary, to be decided by the caller of this function component
         */
        override protected def doBlame[T](blame: Blame): EvalM[T] =
            getPc.flatMap(pc => effectful { collectBlame(pc, blame) } >>> void)

        /** AFter calling a function we need to get its function summary and compose it with our current summary */
        override def afterCall(vlu: Value, targetCmp: Component): EvalM[Value] =
            if functionSummaries(targetCmp).isDefined then
                composeWith(targetCmp, functionSummaries(targetCmp).get) >>> super.afterCall(vlu, targetCmp)
            else super.afterCall(vlu, targetCmp)
