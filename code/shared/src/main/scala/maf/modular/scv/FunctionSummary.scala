package maf.modular.scv

import maf.language.ContractScheme.ContractValues.*
import maf.language.symbolic.*
import maf.core.Address
import maf.core.Monad.MonadSyntaxOps

/** A dataclass that holds all the information needed for a function summary */
case class FunctionSummary[V](
    /**
     * A collection of blames reported by the function, together with the formula that must be true in order fo the blame to be emitted. The second
     * element of the pair indicates whether the formula is satisfiable or not, from the perspective of a caller.
     */
    blames: Map[Blame, (Formula, IsSat[V])],
    /** A collection of paths generated by the execution of the function, as described by its path condition. */
    paths: List[PathCondition],
    /** A collection of addresses used for their symbolic representation in the formulas in the path */
    addresses: List[Address])

/** An analysis that generates function summaries for each function. */
trait FunctionSummaryAnalysis extends BaseScvBigStepSemantics:
    override def intraAnalysis(component: Component): FunctionSummaryIntra

    trait FunctionSummaryIntra extends BaseIntraScvSemantics:
        private var blames: List[(Blame, PathCondition)] = List()

        private def buildSummary(results: Set[(PostValue, PathCondition)]): FunctionSummary[Value] = ???

        /** Stores the summary in a global store such that it is accessible from the otuer intra analyses */
        private def storeSummary(summary: FunctionSummary[Value]): Unit = ???

        /** Registers the blame such that it can be collected in the function summary */
        private def collectBlame(pc: PathCondition, blame: Blame): Unit =
            blames = (blame -> pc) :: blames

        override protected def runIntraSemantics(initialState: State): Set[(PostValue, PathCondition)] =
            val results = super.runIntraSemantics(initialState)
            val summary = buildSummary(results)
            storeSummary(summary)
            results

        /**
         * This specialisation of doBlame does not write the blame directly to the global store, but instead delays that effect by writing it to the
         * function summary, to be decided by the caller of this function component
         */
        override protected def doBlame[T](blame: Blame): EvalM[T] =
            getPc.flatMap(pc => effectful { collectBlame(pc, blame) } >>> void)
